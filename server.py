import socket
import time
import sys
import pb_example_pb2 	# import the module created by protobuf
						# for creating messages
import subprocess    	# module for executing commands from python
						# and retrieving stdout
from thread import *    # import thread module
import chardet
import argparse
import os
import base64
import sqlite3
import binascii
from random import *
import random
from fcrypt import CommonMethod, Encrypt, Decrypt
from cryptography.hazmat.primitives import hmac
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.exceptions import *

used_ports = []

parser = argparse.ArgumentParser()

parser.add_argument("-p", "--server-port", type=int,
                    help="port number of server to connect to")

parser.add_argument("-pr", "--private-key", type=str,
                    help="private key of server")

parser.add_argument("-pu", "--public-key", type=str,
                    help="public key of server")

args = parser.parse_args() 

IP_ADDR = '127.0.0.1'	# use loopback interface
TCP_PORT = args.server_port			# TCP port of server
BUFFER_SIZE = 4096
used_ports.append(args.server_port)

rqst = pb_example_pb2.Request()	# create protobuf Request message
rply = pb_example_pb2.Reply()	# create protobuf Reply message
talk_rqst = pb_example_pb2.talk_request() #create protobuf talk_request message
talk_rply = pb_example_pb2.talk_reply() #create protobuf talk_reply message
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
#reuse the address even if it is in the TIME_WAIT state
sock.bind(('10.110.99.0 ', TCP_PORT))	# bind to port
print sock.getsockname()
sock.listen(100)

def sign_in(conn,addr,server_private_key,server_public_key):
    try:    
        #Fetched name of user who wants to sign in
        name_of_user = Decrypt.asyn_decrypt(base64.b64decode(rqst.payload),server_private_key)
        

        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)
        #These methods are imported from fcrypt.py file
        encrpt = Encrypt()
        decrpt = Decrypt()
        cm = CommonMethod()
        
        #Making sql cursor for accessing database
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()

        #fetching client public key    
        client_public_key_name = decrpt.asyn_decrypt(base64.b64decode(rqst.payload),server_private_key)
        client_public_key = cm.get_public_key(client_public_key_name)
        
        # Decrypting nonce R1 sent by client
        client_r1 = decrpt.asyn_decrypt(base64.b64decode(rqst.nonce_r1),server_private_key)
        #print 'Client r1 is '+ client_r1

        #Generating nonce R2 to be sent to client
        r2 = os.urandom(16)
        rply.nonce_r2 = base64.b64encode(encrpt.asy_encrpt_key(r2,client_public_key))
        
        #Fetching salt for that user which will be sent to user
        sql = "SELECT salt from users where name = ?"
        c.execute(sql,(name_of_user,))
        salt = c.fetchone()
        #print " The salt for user is "+salt[0]
        rply.payload = base64.b64encode(encrpt.asy_encrpt_key(salt[0].encode('UTF-8'),client_public_key))
        conn.send(rply.SerializeToString())
        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)

        #checking wether password hash for the client
        recieved_hash = decrpt.asyn_decrypt(base64.b64decode(rqst.hash),server_private_key)
        a = int(binascii.hexlify(recieved_hash), base=16)
        p = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF
        final_hash = str(pow(2,int(a),p))
        #print 'Recieved HASH is '+ recieved_hash
        #print 'The b64encoded hash is '+ base64.b64encode(recieved_hash)
        recieved_r2 = decrpt.asyn_decrypt(base64.b64decode(rqst.nonce_r2),server_private_key)
        
        # Fetching user name for fina_hash generated by G^(passwordhash received by user)
        sql = "SELECT name from users where password_hash = ?"
        c.execute(sql,(base64.b64encode(final_hash),))
        user_name = c.fetchone()
        #print 'The username fetched from sql is '+ user_name[0] +' and the name is '+ name_of_user
        if user_name == None or name_of_user != user_name[0] or recieved_r2 != r2:
            print 'Please check your username or password'
            rply.sign_in_success = False
            conn.send(rply.SerializeToString())    
            exit()
        else:
            rply.sign_in_success = True

        #Encrypting nonce R1 to be sent to client
        encrypt_r1 = base64.b64encode(encrpt.asy_encrpt_key(client_r1,client_public_key))
        #print 'Client r1 is encrypted '+ encrypt_r1
        rply.nonce_r1 = encrypt_r1
        
        #Generating secret key and salt for this specific session with client
        secret_key = os.urandom(16)
        salt_key = os.urandom(16)
        rply.secret_key = base64.b64encode(encrpt.asy_encrpt_key(secret_key,client_public_key))
        rply.key_salt = base64.b64encode(encrpt.asy_encrpt_key(salt_key,client_public_key))
        #Generating port on which that particular user will listen for other client
        while 1:

            ran = randint(1025,65535)
            # if random port is already being used by someone else generate new port 
            if ran not in used_ports:
                break
        rply.udp_port = ran
        used_ports.append(ran)
        conn.send(rply.SerializeToString())
        #print 'Done sign_in'
        #Inserting Data for the user for this session
        sql = "INSERT into active_users ('name', 'shared_key', 'public_key', 'key_salt', 'port', 'ip') values (?, ?, ?, ?, ?, ?)"
        c.execute(sql,(name_of_user,base64.b64encode(secret_key),client_public_key_name,base64.b64encode(salt_key),str(ran),addr[0]))
        sqlconn.commit()
        sqlconn.close()
        print 'Inserted the data for user'
    except Exception:
        print "Looks Like client left the connection before sign_in"
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        sql = 'DELETE from active_users where name = ?'
        c.execute(sql,(user_name,))
        sqlconn.commit()
        sqlconn.close()
        exit()

def logout(user_name,conn,server_private_key,server_public_key):
<<<<<<< HEAD
    #user_name = Decrypt.asyn_decrypt(base64.b64decode(user_name),server_private_key)
    try:
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        #Fetching shared key and salt for this particular user from database
        sql = 'SELECT * from active_users where name = ?'
        c.execute(sql,(user_name,))
        r = c.fetchone()
        try:
            shared_key = base64.b64decode(r[1])
            key_salt = base64.b64decode(r[3])
            client_public_key_name = r[2]
        except Exception:
            print "Looks like there is no record for this user"
            return
        #print ' The shared secret key from database is '+shared_key
        #print ' The salt is '+key_salt
        #print 'The encrypted nonce_r1 is '+base64.b64decode(rqst.nonce_r1)
        client_public_key = CommonMethod().get_public_key(client_public_key_name)
        #Decrypted the nonce nonce r1 recieved from user
        recieved_r1 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r1),shared_key,key_salt)
        r2 = os.urandom(16)
        #Sending Encrypted nonce r2 from server and also sending r1 back
        rply.nonce_r2 = base64.b64encode(Encrypt().encrypt(r2,shared_key,key_salt))
        rply.nonce_r1 = base64.b64encode(Encrypt().encrypt(recieved_r1,shared_key,key_salt))
        #By default the logout protocol is not completed.
        rply.logout_success = False
        rply.type = pb_example_pb2.Reply.LOGOUT
        conn.send(rply.SerializeToString())
        print "Data sent to user in logout"
        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)
        recieved_r2 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r2),shared_key,key_salt)
        #Deleting the user information for this session from database
        sql = 'DELETE from active_users where name = ?'
        c.execute(sql,(user_name,))
        sqlconn.commit()
        sqlconn.close()
        if recieved_r2 != r2:
            print 'seems like someone else is trying to logout user'
        else:
            #Once whole protocol is completed
            rply.logout_success = True
        conn.send(rply.SerializeToString())
        print 'Logout successfull' 
    except Exception:
        print "Looks like client has left conversation"
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        sql = 'DELETE from active_users where name = ?'
        c.execute(sql,(user_name,))
        sqlconn.commit()
        sqlconn.close()
        exit()
        
"""List protocol is Similar to logout and so to make it different we are sending the
    nonce back decremented by 1.
"""
def list(user_name,conn,server_private_key,server_public_key):
    try:    
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        #Fetching shared key and salt for particular user.
        sql = 'SELECT * from active_users where name = ?'
        c.execute(sql,(user_name,))
        r = c.fetchone()
        print "In logout username  is "+user_name
        try:
            shared_key = base64.b64decode(r[1])
            key_salt = base64.b64decode(r[3])
            client_public_key_name = r[2]
        except Exception:
            print "Looks like there is no record for this user"
            return
        print ' The shared secret key from database is '+shared_key
        print ' The salt is '+key_salt
        print 'The encrypted nonce_r1 is '+base64.b64decode(rqst.nonce_r1)
        client_public_key = CommonMethod().get_public_key(client_public_key_name)
        recieved_r1 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r1),shared_key,key_salt)
        #This random uses os.urandom to generate int.
        r2 = random.SystemRandom().randint(1,1000000000000000000)
        print "The r1 recieved for list is "+recieved_r1
        rply.nonce_r2 = base64.b64encode(Encrypt().encrypt(str(r2),shared_key,key_salt))
        #Sending the recieved nonce r1 minus 1.
        rply.nonce_r1 = base64.b64encode(Encrypt().encrypt(str(int(recieved_r1)-1),shared_key,key_salt))
        #Assigning type of message
        rply.type = pb_example_pb2.Reply.LIST
        conn.send(rply.SerializeToString())
        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)
        recieved_r2 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r2),shared_key,key_salt)
        #Recieved new nonce r1.
        recieved_r1 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r1),shared_key,key_salt)
        print "The second recieved r1 list "+str(recieved_r1)
        rply.nonce_r1 = base64.b64encode(Encrypt().encrypt(str(int(recieved_r1)-1),shared_key,key_salt))
        #This will fetch name of all users who are currently logedin.
        sql = 'Select name from active_users'
        c.execute(sql,())
        users = c.fetchall()
        print users
        sqlconn.close()
        #Here payload will have List of all users loged-in
        rply.payload = base64.b64encode(Encrypt().encrypt(str(users),shared_key,key_salt))
        if int(recieved_r2) != int(r2)-1:
            print 'seems like real user is not requesting for list'
            return
        conn.send(rply.SerializeToString())
        print 'List successfull'
    except Exception:
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        sql = 'DELETE from active_users where name = ?'
        c.execute(sql,(user_name,))
        sqlconn.commit()
        sqlconn.close()
        exit() 

=======
    sqlconn = sqlite3.connect("db.sqlite")
    c = sqlconn.cursor()
    sql = 'SELECT * from active_users where name = ?'
    c.execute(sql,(user_name,))
    r = c.fetchone()
    shared_key = base64.b64decode(r[1])
    key_salt = base64.b64decode(r[3])
    client_public_key_name = r[2]
    print ' The shared secret key from database is '+shared_key
    print ' The salt is '+key_salt
    print 'The encrypted nonce_r1 is '+base64.b64decode(rqst.nonce_r1)
    client_public_key = CommonMethod().get_public_key(client_public_key_name)
    recieved_r1 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r1),shared_key,key_salt)
    r2 = os.urandom(16)
    rply.nonce_r2 = base64.b64encode(Encrypt().encrypt(r2,shared_key,key_salt))
    rply.nonce_r1 = base64.b64encode(Encrypt().encrypt(recieved_r1,shared_key,key_salt))
    rply.logout_success = False
    rply.type = pb_example_pb2.Reply.LOGOUT
    conn.send(rply.SerializeToString())
    data = conn.recv(BUFFER_SIZE)
    rqst.ParseFromString(data)
    recieved_r2 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r2),shared_key,key_salt)
    sql = 'DELETE from active_users where name = ?'
    c.execute(sql,(user_name,))
    sqlconn.commit()
    sqlconn.close()
    if recieved_r2 != r2:
        print 'seems like someone else is trying to logout user'
    rply.logout_success = True
    conn.send(rply.SerializeToString())
    print 'Logout successfull' 


def process_talk(conn,rqst):
    username = rqst.username
    # uername = Decrypt.decrypt_message(username,shared_key,iv)
    print 'Username received is ' + username
    sqlconn = sqlite3.connect("db.sqlite")
    c = sqlconn.cursor()
    sql = 'SELECT * from active_users where name = ?'
    c.execute(sql,(rqst.username,))
    r = c.fetchone()
    if r is None:
        print "Seems that user who sent the talk request is not online"
    else:
        symmetric_key_user1 = base64.b64decode(r[1])
        print 'Symmetric key of user 1'
        print symmetric_key_user1
        iv_user1 = base64.b64decode(r[3])
        print 'IV of user1'
        print iv_user1
        decrypted_user2 = base64.b64decode(rqst.talk_to_user)
        decrypted_user2 = Decrypt.decrypt_message(decrypted_user2,symmetric_key_user1,iv_user1)
        print 'Received request to talk to:'
        print decrypted_user2
        rply.nonce_r1 = rqst.nonce_r1
        r2 = os.urandom(16)
        rply.nonce_r2 = base64.b64encode(Encrypt.encrypt(r2,symmetric_key_user1,iv_user1))
        rply.type = pb_example_pb2.Reply.TALK
        conn.send(rply.SerializeToString())
        print 'R1 and R2 sent to client'
        nonce_data = conn.recv(BUFFER_SIZE)
        if not nonce_data:
            print 'No response received. Exiting..'
            exit()
        rply.ParseFromString(nonce_data)
        decrypted_r2 = base64.b64decode(rply.nonce_r2)
        decrypted_r2 = Decrypt.decrypt_message(decrypted_r2,symmetric_key_user1,iv_user1)
        print 'R2 decrypted successfully'
        if r2 != decrypted_r2:
            print 'R2 does not match, something is wrong. Exiting'
            exit()
        sql = 'SELECT * from active_users where name = ?'
        c.execute(sql,(decrypted_user2,))
        result_user2 = c.fetchone()
        if result_user2 is None:
            print 'User does not exist'
            exit()
        symmetric_key_user2 = base64.b64decode(result_user2[1])
        print 'symmetric key of user2 is :'
        print symmetric_key_user2
        print 'IV of user2 is: '
        iv_user2 = base64.b64decode(result_user2[3])
        print iv_user2
        print 'Username is'
        print username
        temp_username = username
        # username = base64.b64encode(username)
        username = username.encode('utf-8')
        print 'Encoded username before encrypting'
        print username
        encrypted_username = Encrypt.encrypt(username,symmetric_key_user2,iv_user2)
        sql = 'SELECT public_key from user_public_key where name = ?'
        c.execute(sql,(temp_username,))
        result_key1 = str(c.fetchone()[0])
        if result_key1 is None:
            print 'User is not present.'
            exit()
        encrypted_pku1 = Encrypt.encrypt(result_key1,symmetric_key_user2,iv_user2)
        sql = 'SELECT public_key from user_public_key where name = ?'
        c.execute(sql,(decrypted_user2,))
        result_key2 = str(c.fetchone()[0])
        if result_key2 is None:
            print 'User is not present.'
            exit()
        encrypted_pku2 = Encrypt.encrypt(result_key2,symmetric_key_user1,iv_user1)
        rply.username = base64.b64encode(encrypted_username)
        rply.public_key_u1 = base64.b64encode(encrypted_pku1)
        rply.public_key_u2 = base64.b64encode(encrypted_pku2)
        conn.send(rply.SerializeToString())
        print 'Data sent from server -- Last message'



        # cipher = Cipher(algorithms.AES(shared_key), modes.CTR(iv),backend = default_backend())
        # rply.username = username
        # rply.nonce_r1 = rqst.nonce_r1
        # r2 = os.urandom(16)
        # print 'R2 is: ' + r2
        # usr = base64.b64decode(rqst.talk_to_user)
        # talk_to_user = Decrypt.decrypt_message(usr,shared_key,iv)
        # print 'Received request to talk to ' + talk_to_user
        # encrypted_r2 = base64.b64encode(Encrypt.encrypt(r2,shared_key,iv))
        # rply.nonce_r2 = encrypted_r2.decode('utf-8')
        # rply.type = pb_example_pb2.Reply.TALK
        # conn.send(rply.SerializeToString())  # serialize response into string and send
        # print 'Data sent to client'
        # data = conn.recv(BUFFER_SIZE)
        # if not data: 
        #     print 'No response received.'
        #     sys.exit()
        # rply.ParseFromString(data)
        # nonce = base64.b64decode(rply.nonce_r2)
        # nonced = Decrypt.decrypt_message(nonce,shared_key,iv)
        # print nonced
        # if nonced == r2:
        #     su2 = os.urandom(16)
        #     print 'User to talk to is ' + talk_to_user
        #     sqlconn = sqlite3.connect("db.sqlite")
        #     c = sqlconn.cursor()
        #     sql = 'SELECT * from active_users where name = ?'
        #     decode_usr = talk_to_user.decode('utf-8')
        #     c.execute(sql,(decode_usr,))
        #     result = c.fetchone()
        #     if result is None:
        #         print "DK went wrong."
        #         sys.exit()
        #     else:
        #         print 'Result should be'
        #         print result
        #         shared_key_u2 = base64.b64decode(result[1])
        #         sql = 'SELECT public_key from user_public_key where name = ?'
        #         decode_username = str(username.decode('utf-8'))
        #         c.execute(sql,(decode_username,))
        #         res_u1 = str(c.fetchone()[0])
        #         print 'File name is '
        #         print res_u1
        #         ec = CommonMethod()
        #         # res_u1 = str(ec.get_public_key(res_u1))
        #         print "Public key is: " 
        #         print res_u1
        #         c.execute(sql,(decode_usr,))
        #         # print 'Type from database is:-----------------'
        #         # print type(c.fetchone()[0])
        #         res_u2 = (str(c.fetchone()[0])) 
        #         print res_u2
        #         # res_u2 = str(ec.get_public_key(res_u2))
        #         # iv = os.urandom(16)
        #         # cipher = Cipher(algorithms.AES(shared_key), modes.CTR(iv),backend = default_backend())
        #         print 'Username is' + username
        #         print shared_key_u2
        #         print '---------------Here is the shared key -----------'
        #         # res_u1 = res_u1.encode('utf-8')
        #         # res_u2 = res_u2.encode('utf-8')
        #         username = username.encode('utf-8')
        #         # shared_key_u2= shared_key_u2.encode('utf-8')
        #         print 'Sharedkey after encoding ----------------'
        #         print shared_key_u2
        #         print iv
        #         encrypted_username = Encrypt.encrypt(username,shared_key_u2,iv)
        #         # print 'Username encrypted with shared key of user2 is '
        #         # print encrypted_username
        #         encrypted_pku1 = Encrypt.encrypt(res_u1,shared_key_u2,iv) 
        #         print '----------------Encrypted 1st pku1'
        #         print encrypted_pku1
        #         # print 'IV  is: '
        #         # print iv
        #         # print 'shared key is: '
        #         # print shared_key_u2
        #         encrypted_pku2 = Encrypt.encrypt(res_u2,shared_key,iv)
        #         shared_encrypted_username = Encrypt.encrypt(encrypted_username,shared_key,iv)
        #         print 'Username shared and encrypted with su1 is:'
        #         print shared_encrypted_username 
        #         shared_encrypted_pku1 = Encrypt.encrypt(encrypted_pku1,shared_key,iv)
        #         rply.public_key_u1 = (base64.b64encode(shared_encrypted_pku1))#.encode('utf-8')
        #         print 'Encoding in server -pku1'
        #         print rply.public_key_u1
        #         rply.public_key_u2 = (base64.b64encode(encrypted_pku2))#.encode('utf-8')
        #         print 'Username that you want is :'
        #         rply.username = (base64.b64encode(shared_encrypted_username))#.encode('utf-8')
        #         print rply.username
        #         print 'Executed'
        #         conn.send(rply.SerializeToString())
        # else:
        #     print 'Nonces do not match'
>>>>>>> 19b85d48288c23537b1e424f8d9ed6b3339b6bb3


def start_connection(conn,addr):
    user_name = ""
    ec = CommonMethod()
    server_private_key = ec.get_private_key(args.private_key)
    server_public_key = ec.get_public_key(args.public_key)
    
    while 1:                # process one request at a time
        data = conn.recv(BUFFER_SIZE)
        if not data: 
            break

        print "received data..."

        rqst.ParseFromString(data)  # parse message
        if (rqst.type == pb_example_pb2.Request.SIGN): # SIGN-IN request
            sqlconn = sqlite3.connect("db.sqlite")
            c = sqlconn.cursor()
            #Fetching wether there is a session already running for this user
            sql = 'SELECT count(*) from active_users where name = ?'
            user_name = Decrypt.asyn_decrypt(base64.b64decode(rqst.payload),server_private_key)
            user_name = user_name.encode('UTF-8')
            count = c.execute(sql,(user_name,))
            co = count.fetchall()
            sqlconn.close()
            print "The count of sql querry is "
            print co
            print type(co)
            """If there is a session running we will get 1 as output. If there is a seesion running.
               Server will authenticate user first and if it is able to authenticte the user it will
               remove the previous session and start new session.
            """
            if co[0][0] != 0 :
                #print 'Already online seems like you already have a session running'
                sqlconn = sqlite3.connect("db.sqlite")
                c = sqlconn.cursor()
                sql = 'SELECT shared_key from active_users where name = ?'
                c.execute(sql,(user_name,))
                share = c.fetchall()
                #print "The type of share is "
                #print type(share)
                #print share
                sign_in(conn,addr,server_private_key,server_public_key)
                sql = 'DELETE from active_users where shared_key = ?'
                c.execute(sql,(share[0][0],))
                sqlconn.commit()
                sqlconn.close()            
            else:
                print 'Welcome: '+user_name
                sign_in(conn,addr,server_private_key,server_public_key)   # just copy payload
            print 'Sign in is done'

        if rqst.type == pb_example_pb2.Request.LOGOUT:
            print "Calling logout username  is "+user_name
            logout(user_name,conn,server_private_key,server_public_key)
            print "Logout is done"
            exit()

        if rqst.type == pb_example_pb2.Request.LIST:           
            list(user_name,conn,server_private_key,server_public_key)
            print "List is done"

<<<<<<< HEAD
if __name__ == '__main__':
    while 1:
        print "Listening again"
        conn, addr = sock.accept()	# accept connection from client
        print 'ADDR : '+ str(addr[1])
        print 'CONN : '+ str(conn)
        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)  # parse message
        """ Here the user will first initiate his willingness to communicate with message
            type equal to POF1. Here the server will send a hash generated by combining
            IP, port and some secret number. User need to find that secret used to generate hash.
            Than user will come back with sec and messgae type equal to POF2 and if the secret messgae
            matched in database the server intiates the sign_in ptocess or else it closes connection.
        """
        if rqst.type == pb_example_pb2.Request.POF_1:
            sqlconn = sqlite3.connect("db.sqlite")
            c = sqlconn.cursor()
            print "Querying for first time"
            #Generating secret int for user to find for PROOF OF WORK.
            sec = random.SystemRandom().randint(1,1000000)
            print "The secret is "+str(sec)
            print "The ip is "+addr[0]
            print "The port is "+str(addr[1])
            sec_hash = CommonMethod().generate_hash(addr[0]+str(addr[1])+str(sec))
            #Storing secret mapped with IP and PORT.
            sql = "INSERT into proof_of_work ('ip', 'port', 'sec') values (?, ?, ?)"
            c.execute(sql,(addr[0],addr[1],sec))
            sqlconn.commit()
            sqlconn.close()
            rply.hash = base64.b64encode(sec_hash)
            rply.ip = addr[0]
            rply.port = str(addr[1])
            try:
                conn.send(rply.SerializeToString())
            except Exception:
                print "Looks like client left"
                conn.close()
                continue
            conn.close()
            continue
        if rqst.type == pb_example_pb2.Request.POF_2:    
            sqlconn = sqlite3.connect("db.sqlite")
            c = sqlconn.cursor()
            ip = rqst.ip
            port = rqst.port
            print "The secret is "+rqst.payload
            print "The ip is "+ip
            print "The port is "+port
            #Fetching secret for that particular IP and port provided by user 
            sql = "SELECT sec from proof_of_work WHERE ip = ? and port = ?"
            sql_querry = c.execute(sql,(ip,port))
            sec = sql_querry.fetchone()
            sql = 'DELETE from proof_of_work WHERE ip = ? and port = ?'
            c.execute(sql,(ip,port))
            sqlconn.commit()
            sqlconn.close()
            print "Quering with sec"
            print "The secret fetched from database is "+str(sec)
            try:
                if rqst.payload == str(sec[0]):
                    rply.pof_success = True
                    conn.send(rply.SerializeToString())
                    start_new_thread(start_connection,(conn,addr))
                    print 'Connection address:', addr
                else:
                    rply.pof_success = False
                    print "Secret returned is not correct"
                    conn.send(rply.SerializeToString())
            except Exception:
                print "Looks like database doesnot have any record for this particular IP and port combination"
                conn.close()
                continue        
=======
while 1:
    print "Listening again"
    conn, addr = sock.accept()	# accept connection from client
    print 'ADDR : '+ str(addr[1])
    print 'CONN : '+ str(conn)
    data = conn.recv(BUFFER_SIZE)
    rqst.ParseFromString(data)  # parse message
    # if rqst.type == pb_example_pb2.Request.TALK:           
    #         process_talk(conn,rqst)
    if rqst.type == pb_example_pb2.Request.POF_1:
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        print "Querying for first time"
        sec = randint(1, 1000000)
        print "The secret is "+str(sec)
        print "The ip is "+addr[0]
        print "The port is "+str(addr[1])
        sec_hash = CommonMethod().generate_hash(addr[0]+str(addr[1])+str(sec))
        sql = "INSERT into proof_of_work ('ip', 'port', 'sec') values (?, ?, ?)"
        c.execute(sql,(addr[0],addr[1],sec))
        sqlconn.commit()
        sqlconn.close()
        rply.hash = base64.b64encode(sec_hash)
        rply.ip = addr[0]
        rply.port = str(addr[1])
        conn.send(rply.SerializeToString())
        conn.close()
        continue
    if rqst.type == pb_example_pb2.Request.POF_2:    
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        ip = rqst.ip
        port = rqst.port
        print "The secret is "+rqst.payload
        print "The ip is "+ip
        print "The port is "+port
        sql = "SELECT sec from proof_of_work WHERE ip = ? and port = ?"
        sql_querry = c.execute(sql,(ip,port))
        sec = sql_querry.fetchone()
        sql = 'DELETE from proof_of_work WHERE ip = ? and port = ?'
        c.execute(sql,(ip,port))
        sqlconn.commit()
        sqlconn.close()
        print "Quering with sec"
        print "The secret fetched from database is "+str(sec)
        if rqst.payload == str(sec[0]):
            rply.pof_success = True
            conn.send(rply.SerializeToString())
            start_new_thread(start_connection,(conn,addr))
            print 'Connection address:', addr
        else:
            rply.pof_success = False
            print "Secret returned is not correct"
            conn.send(rply.SerializeToString())
            
>>>>>>> 19b85d48288c23537b1e424f8d9ed6b3339b6bb3
