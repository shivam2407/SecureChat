import socket
import time
import sys
import pb_example_pb2 	# import the module created by protobuf
						# for creating messages
import subprocess    	# module for executing commands from python
						# and retrieving stdout
from thread import *    # import thread module
import chardet
import argparse
import os
import base64
import sqlite3
import binascii
from random import *
import random
from fcrypt import CommonMethod, Encrypt, Decrypt
from cryptography.hazmat.primitives import hmac
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.exceptions import *

used_ports = []

parser = argparse.ArgumentParser()

parser.add_argument("-p", "--server-port", type=int,
                    help="port number of server to connect to")

parser.add_argument("-pr", "--private-key", type=str,
                    help="private key of server")

parser.add_argument("-pu", "--public-key", type=str,
                    help="public key of server")

args = parser.parse_args() 

IP_ADDR = '127.0.0.1'	# use loopback interface
TCP_PORT = args.server_port			# TCP port of server
BUFFER_SIZE = 4096
used_ports.append(args.server_port)

rqst = pb_example_pb2.Request()	# create protobuf Request message
rply = pb_example_pb2.Reply()	# create protobuf Reply message
try:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
#reuse the address even if it is in the TIME_WAIT state
    sock.bind(('', TCP_PORT))	# bind to port
    sock.listen(100)
except Exception:
    print "Wrong Format. The correct Format is"
    print "python server.py -p PORT -pk PRIMARY KEY -pu PUBLIC KEY"
    exit()

def sign_in(conn,addr,server_private_key,server_public_key):
    try:    
        #Fetched name of user who wants to sign in
        name_of_user = Decrypt.asyn_decrypt(base64.b64decode(rqst.payload),server_private_key)
        

        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)
        #These methods are imported from fcrypt.py file
        encrpt = Encrypt()
        decrpt = Decrypt()
        cm = CommonMethod()
        
        #Making sql cursor for accessing database
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()

        #fetching client public key    
        client_public_key_name = decrpt.asyn_decrypt(base64.b64decode(rqst.payload),server_private_key)
        client_public_key = cm.get_public_key(client_public_key_name)
        
        # Decrypting nonce R1 sent by client
        client_r1 = decrpt.asyn_decrypt(base64.b64decode(rqst.nonce_r1),server_private_key)
        #print 'Client r1 is '+ client_r1

        #Generating nonce R2 to be sent to client
        r2 = os.urandom(16)
        rply.nonce_r2 = base64.b64encode(encrpt.asy_encrpt_key(r2,client_public_key))
        
        #Fetching salt for that user which will be sent to user
        sql = "SELECT salt from users where name = ?"
        c.execute(sql,(name_of_user,))
        salt = c.fetchone()
        #print " The salt for user is "+salt[0]
        rply.payload = base64.b64encode(encrpt.asy_encrpt_key(salt[0].encode('UTF-8'),client_public_key))
        conn.send(rply.SerializeToString())
        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)

        #checking wether password hash for the client
        recieved_hash = decrpt.asyn_decrypt(base64.b64decode(rqst.hash),server_private_key)
        a = int(binascii.hexlify(recieved_hash), base=16)
        p = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF
        final_hash = str(pow(2,int(a),p))
        #print 'Recieved HASH is '+ recieved_hash
        #print 'The b64encoded hash is '+ base64.b64encode(recieved_hash)
        recieved_r2 = decrpt.asyn_decrypt(base64.b64decode(rqst.nonce_r2),server_private_key)
        
        # Fetching user name for fina_hash generated by G^(passwordhash received by user)
        sql = "SELECT name from users where password_hash = ?"
        c.execute(sql,(base64.b64encode(final_hash),))
        user_name = c.fetchone()
        #print 'The username fetched from sql is '+ user_name[0] +' and the name is '+ name_of_user
        if user_name == None or name_of_user != user_name[0] or recieved_r2 != r2:
            print 'Please check your username or password'
            rply.sign_in_success = False
            conn.send(rply.SerializeToString())    
            exit()
        else:
            rply.sign_in_success = True

        #Encrypting nonce R1 to be sent to client
        encrypt_r1 = base64.b64encode(encrpt.asy_encrpt_key(client_r1,client_public_key))
        #print 'Client r1 is encrypted '+ encrypt_r1
        rply.nonce_r1 = encrypt_r1
        
        #Generating secret key and salt for this specific session with client
        secret_key = os.urandom(16)
        salt_key = os.urandom(16)
        rply.secret_key = base64.b64encode(encrpt.asy_encrpt_key(secret_key,client_public_key))
        rply.key_salt = base64.b64encode(encrpt.asy_encrpt_key(salt_key,client_public_key))
        #Generating port on which that particular user will listen for other client
        while 1:

            ran = randint(1025,65535)
            # if random port is already being used by someone else generate new port 
            if ran not in used_ports:
                break
        rply.udp_port = ran
        used_ports.append(ran)
        conn.send(rply.SerializeToString())
        #print 'Done sign_in'
        #Inserting Data for the user for this session
        sql = "INSERT into active_users ('name', 'shared_key', 'public_key', 'key_salt', 'port', 'ip') values (?, ?, ?, ?, ?, ?)"
        c.execute(sql,(name_of_user,base64.b64encode(secret_key),client_public_key_name,base64.b64encode(salt_key),str(ran),addr[0]))
        sqlconn.commit()
        sqlconn.close()
        print 'Inserted the data for user'
    except Exception:
        print "Looks Like client left the connection before sign_in"
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        sql = 'DELETE from active_users where name = ?'
        c.execute(sql,(user_name,))
        sqlconn.commit()
        sqlconn.close()
        exit()

def logout(user_name,conn,server_private_key,server_public_key):
    #user_name = Decrypt.asyn_decrypt(base64.b64decode(user_name),server_private_key)
    try:
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        #Fetching shared key and salt for this particular user from database
        sql = 'SELECT * from active_users where name = ?'
        c.execute(sql,(user_name,))
        r = c.fetchone()
        try:
            shared_key = base64.b64decode(r[1])
            key_salt = base64.b64decode(r[3])
            client_public_key_name = r[2]
        except Exception:
            print "Looks like there is no record for this user"
            return
        #print ' The shared secret key from database is '+shared_key
        #print ' The salt is '+key_salt
        #print 'The encrypted nonce_r1 is '+base64.b64decode(rqst.nonce_r1)
        client_public_key = CommonMethod().get_public_key(client_public_key_name)
        #Decrypted the nonce nonce r1 recieved from user
        recieved_r1 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r1),shared_key,key_salt)
        r2 = os.urandom(16)
        #Sending Encrypted nonce r2 from server and also sending r1 back
        rply.nonce_r2 = base64.b64encode(Encrypt().encrypt(r2,shared_key,key_salt))
        rply.nonce_r1 = base64.b64encode(Encrypt().encrypt(recieved_r1,shared_key,key_salt))
        #By default the logout protocol is not completed.
        rply.logout_success = False
        rply.type = pb_example_pb2.Reply.LOGOUT
        conn.send(rply.SerializeToString())
        print "Data sent to user in logout"
        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)
        recieved_r2 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r2),shared_key,key_salt)
        #Deleting the user information for this session from database
        sql = 'DELETE from active_users where name = ?'
        c.execute(sql,(user_name,))
        sqlconn.commit()
        sqlconn.close()
        if recieved_r2 != r2:
            print 'seems like someone else is trying to logout user'
        else:
            #Once whole protocol is completed
            rply.logout_success = True
        conn.send(rply.SerializeToString())
        print 'Logout successfull' 
    except Exception:
        print "Looks like client has left conversation"
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        sql = 'DELETE from active_users where name = ?'
        c.execute(sql,(user_name,))
        sqlconn.commit()
        sqlconn.close()
        exit()
        
"""List protocol is Similar to logout and so to make it different we are sending the
    nonce back decremented by 1.
"""
def list(user_name,conn,server_private_key,server_public_key):
    try:    
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        #Fetching shared key and salt for particular user.
        sql = 'SELECT * from active_users where name = ?'
        c.execute(sql,(user_name,))
        r = c.fetchone()
        print "In logout username  is "+user_name
        try:
            shared_key = base64.b64decode(r[1])
            key_salt = base64.b64decode(r[3])
            client_public_key_name = r[2]
        except Exception:
            print "Looks like there is no record for this user"
            return
        print ' The shared secret key from database is '+shared_key
        print ' The salt is '+key_salt
        print 'The encrypted nonce_r1 is '+base64.b64decode(rqst.nonce_r1)
        client_public_key = CommonMethod().get_public_key(client_public_key_name)
        recieved_r1 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r1),shared_key,key_salt)
        #This random uses os.urandom to generate int.
        r2 = random.SystemRandom().randint(1,1000000000000000000)
        print "The r1 recieved for list is "+recieved_r1
        rply.nonce_r2 = base64.b64encode(Encrypt().encrypt(str(r2),shared_key,key_salt))
        #Sending the recieved nonce r1 minus 1.
        rply.nonce_r1 = base64.b64encode(Encrypt().encrypt(str(int(recieved_r1)-1),shared_key,key_salt))
        #Assigning type of message
        rply.type = pb_example_pb2.Reply.LIST
        conn.send(rply.SerializeToString())
        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)
        recieved_r2 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r2),shared_key,key_salt)
        #Recieved new nonce r1.
        recieved_r1 = Decrypt().decrypt_message(base64.b64decode(rqst.nonce_r1),shared_key,key_salt)
        print "The second recieved r1 list "+str(recieved_r1)
        rply.nonce_r1 = base64.b64encode(Encrypt().encrypt(str(int(recieved_r1)-1),shared_key,key_salt))
        #This will fetch name of all users who are currently logedin.
        sql = 'Select name from active_users'
        c.execute(sql,())
        users = c.fetchall()
        print users
        sqlconn.close()
        #Here payload will have List of all users loged-in
        rply.payload = base64.b64encode(Encrypt().encrypt(str(users),shared_key,key_salt))
        if int(recieved_r2) != int(r2)-1:
            print 'seems like real user is not requesting for list'
            return
        conn.send(rply.SerializeToString())
        print 'List successfull'
    except Exception:
        sqlconn = sqlite3.connect("db.sqlite")
        c = sqlconn.cursor()
        sql = 'DELETE from active_users where name = ?'
        c.execute(sql,(user_name,))
        sqlconn.commit()
        sqlconn.close()
        exit() 

#start the process to talk to user 2
def process_talk(conn,rqst):
    #Get username of the user who wants to send a message to another user
    username = rqst.username
    #Check if user1 is online
    sqlconn = sqlite3.connect("db.sqlite")
    c = sqlconn.cursor()
    sql = 'SELECT * from active_users where name = ?'
    c.execute(sql,(rqst.username,))
    r = c.fetchone()
    #If user is not in the active users list,
    if r is None:
        print "Seems that user who sent the talk request is not online. Please sign-in in order to talk"
    else:
    #Fetch the shared key of user1-server to encrypt name of user2 and R1
        symmetric_key_user1 = base64.b64decode(r[1])
    #Fetch the IV for symmetric encryption
        iv_user1 = base64.b64decode(r[3])
    #Decrypt name of user2 using shared key of user1-server
        decrypted_user2 = base64.b64decode(rqst.talk_to_user)
        decrypted_user2 = Decrypt.decrypt_message(decrypted_user2,symmetric_key_user1,iv_user1)
        print 'Received request to talk to:'
        print decrypted_user2
    #Send the R1 generated by user1 back to user 1 alongwith r2 generated by server
        rply.nonce_r1 = rqst.nonce_r1
        r2 = os.urandom(16)
    #Encrypt R2 generated by server with the shared key of user1-server
        rply.nonce_r2 = base64.b64encode(Encrypt.encrypt(r2,symmetric_key_user1,iv_user1))
    #Type of the message is TALK
        rply.type = pb_example_pb2.Reply.TALK
    #Send the nonces to R1 and R2
        conn.send(rply.SerializeToString())
    #Receive the R2 from User1.
        nonce_data = conn.recv(BUFFER_SIZE)
        if not nonce_data:
            print 'No response received. Exiting..'
            exit()
        rply.ParseFromString(nonce_data)
    # Derypt the R2 sent by user1
        decrypted_r2 = base64.b64decode(rply.nonce_r2)
        decrypted_r2 = Decrypt.decrypt_message(decrypted_r2,symmetric_key_user1,iv_user1)
    #If R2 same as the one Server sent, continue, else exit
        if r2 != decrypted_r2:
            print 'R2 does not match, something is wrong. Exiting'
            exit()
    #Fetch the shared key and iv of user2-server from the database to encrypt ticket-to-user2 with
        sql = 'SELECT * from active_users where name = ?'
        c.execute(sql,(decrypted_user2,))
        result_user2 = c.fetchone()
        if result_user2 is None:
            print 'User does not exist'
            exit()
        symmetric_key_user2 = base64.b64decode(result_user2[1])
        iv_user2 = base64.b64decode(result_user2[3])
        temp_username = username
        username = username.encode('utf-8')
        #Encrypt user1's username with server-user2 shared key
        encrypted_username = Encrypt.encrypt(username,symmetric_key_user2,iv_user2)
        shared_encrypted_username = Encrypt.encrypt(encrypted_username,symmetric_key_user1,iv_user1)
        sql = 'SELECT public_key from user_public_key where name = ?'
        c.execute(sql,(temp_username,))
        #Get public key of user1 from database and encrypt with server-user2 shared key
        result_key1 = str(c.fetchone()[0])
        if result_key1 is None:
            print 'User is not present.'
            exit()
        encrypted_pku1 = Encrypt.encrypt(result_key1,symmetric_key_user2,iv_user2)
        shared_encrypted_pku1 = Encrypt.encrypt(encrypted_pku1,symmetric_key_user1,iv_user1)
        #Get public key of user2 from database and encrypt with server-user1 shared key to send to user1
        sql = 'SELECT public_key from user_public_key where name = ?'
        c.execute(sql,(decrypted_user2,))
        result_key2 = str(c.fetchone()[0])
        if result_key2 is None:
            print 'User is not present.'
            exit()
        #Fetch ip and port details of users who are online
        sql = 'SELECT port,ip from active_users where name = ?'
        c.execute(sql,(decrypted_user2,))
        result = c.fetchone()
        port = result[0]
        port = int(port)
        ip = result[1]
        # ip = ip.encode('utf-8')
        #Set the message to send to user1
        encrypted_pku2 = Encrypt.encrypt(result_key2,symmetric_key_user1,iv_user1)
        rply.username = base64.b64encode(shared_encrypted_username)
        rply.public_key_u1 = base64.b64encode(shared_encrypted_pku1)
        rply.public_key_u2 = base64.b64encode(encrypted_pku2)
        rply.port = port
        rply.ip = base64.b64encode(ip)
        conn.send(rply.SerializeToString())



def start_connection(conn,addr):
    user_name = ""
    ec = CommonMethod()
    server_private_key = ec.get_private_key(args.private_key)
    server_public_key = ec.get_public_key(args.public_key)
    
    while 1:                # process one request at a time
        data = conn.recv(BUFFER_SIZE)
        if not data: 
            break

        print "received data..."

        rqst.ParseFromString(data)  # parse message
        if (rqst.type == pb_example_pb2.Request.SIGN): # SIGN-IN request
            sqlconn = sqlite3.connect("db.sqlite")
            c = sqlconn.cursor()
            #Fetching wether there is a session already running for this user
            sql = 'SELECT count(*) from active_users where name = ?'
            user_name = Decrypt.asyn_decrypt(base64.b64decode(rqst.payload),server_private_key)
            user_name = user_name.encode('UTF-8')
            count = c.execute(sql,(user_name,))
            co = count.fetchall()
            sqlconn.close()
            print "The count of sql querry is "
            print co
            print type(co)
            """If there is a session running we will get 1 as output. If there is a seesion running.
               Server will authenticate user first and if it is able to authenticte the user it will
               remove the previous session and start new session.
            """
            if co[0][0] != 0 :
                #print 'Already online seems like you already have a session running'
                sqlconn = sqlite3.connect("db.sqlite")
                c = sqlconn.cursor()
                sql = 'SELECT shared_key from active_users where name = ?'
                c.execute(sql,(user_name,))
                share = c.fetchall()
                #print "The type of share is "
                #print type(share)
                #print share
                sign_in(conn,addr,server_private_key,server_public_key)
                sql = 'DELETE from active_users where shared_key = ?'
                c.execute(sql,(share[0][0],))
                sqlconn.commit()
                sqlconn.close()            
            else:
                print 'Welcome: '+user_name
                sign_in(conn,addr,server_private_key,server_public_key)   # just copy payload
            print 'Sign in is done'

        if rqst.type == pb_example_pb2.Request.LOGOUT:
            print "Calling logout username  is "+user_name
            logout(user_name,conn,server_private_key,server_public_key)
            print "Logout is done"
            exit()

        if rqst.type == pb_example_pb2.Request.LIST:           
            list(user_name,conn,server_private_key,server_public_key)
            print "List is done"

if __name__ == '__main__':
    while 1:
        print "Listening again"
        conn, addr = sock.accept()	# accept connection from client
        print 'ADDR : '+ str(addr[1])
        print 'CONN : '+ str(conn)
        data = conn.recv(BUFFER_SIZE)
        rqst.ParseFromString(data)  # parse message
        """ Here the user will first initiate his willingness to communicate with message
            type equal to POF1. Here the server will send a hash generated by combining
            IP, port and some secret number. User need to find that secret used to generate hash.
            Than user will come back with sec and messgae type equal to POF2 and if the secret messgae
            matched in database the server intiates the sign_in ptocess or else it closes connection.
        """
        if rqst.type == pb_example_pb2.Request.POF_1:
            sqlconn = sqlite3.connect("db.sqlite")
            c = sqlconn.cursor()
            print "Querying for first time"
            #Generating secret int for user to find for PROOF OF WORK.
            sec = random.SystemRandom().randint(1,1000000)
            print "The secret is "+str(sec)
            print "The ip is "+addr[0]
            print "The port is "+str(addr[1])
            sec_hash = CommonMethod().generate_hash(addr[0]+str(addr[1])+str(sec))
            #Storing secret mapped with IP and PORT.
            sql = "INSERT into proof_of_work ('ip', 'port', 'sec') values (?, ?, ?)"
            c.execute(sql,(addr[0],addr[1],sec))
            sqlconn.commit()
            sqlconn.close()
            rply.hash = base64.b64encode(sec_hash)
            rply.ip = addr[0]
            rply.port = str(addr[1])
            try:
                conn.send(rply.SerializeToString())
            except Exception:
                print "Looks like client left"
                conn.close()
                continue
            conn.close()
            continue
        if rqst.type == pb_example_pb2.Request.POF_2:    
            sqlconn = sqlite3.connect("db.sqlite")
            c = sqlconn.cursor()
            ip = rqst.ip
            port = rqst.port
            print "The secret is "+rqst.payload
            print "The ip is "+ip
            print "The port is "+port
            #Fetching secret for that particular IP and port provided by user 
            sql = "SELECT sec from proof_of_work WHERE ip = ? and port = ?"
            sql_querry = c.execute(sql,(ip,port))
            sec = sql_querry.fetchone()
            sql = 'DELETE from proof_of_work WHERE ip = ? and port = ?'
            c.execute(sql,(ip,port))
            sqlconn.commit()
            sqlconn.close()
            print "Quering with sec"
            print "The secret fetched from database is "+str(sec)
            try:
                if rqst.payload == str(sec[0]):
                    rply.pof_success = True
                    conn.send(rply.SerializeToString())
                    start_new_thread(start_connection,(conn,addr))
                    print 'Connection address:', addr
                else:
                    rply.pof_success = False
                    print "Secret returned is not correct"
                    conn.send(rply.SerializeToString())
            except Exception:
                print "Looks like database doesnot have any record for this particular IP and port combination"
                conn.close()
                continue        
